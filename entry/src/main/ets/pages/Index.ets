import { abilityAccessCtrl, common, PermissionRequestResult ,Permissions } from '@kit.AbilityKit';
import { sensor } from '@kit.SensorServiceKit';
import { BusinessError } from '@kit.BasicServicesKit';
import window from '@ohos.window';
import { geoLocationManager } from '@kit.LocationKit';
import http from '@ohos.net.http';

//æµ‹è¯•å»¶æ—¶ç”¨
let now_time: number = 0;
let last_time: number = 0;

//ä¸Šä¼ æ•°æ®åŒ…æ ¡éªŒä½
let check: number = 0;

//gpså®šæ—¶å™¨
let gpsTimer: number | undefined = undefined;

// 1. å®šä¹‰å¿…è¦çš„æ¥å£
interface TestData {
  key1: string;
  key2: string;
}

interface HttpHeaders {
  "Content-Type": string;
}

interface RequestContent {
  content: string;
  headers: HttpHeaders;
}

interface UploadData {
  heartRate: number;
  location: number[];    // [ç»åº¦, çº¬åº¦]
  sensorData: number[];  // [x, y, z] åŠ é€Ÿåº¦
  timestamp: number;     // æ·»åŠ æ—¶é—´æˆ³
}

// ä¸Šä¼ æ•°æ®æ ¼å¼ï¼ˆå¸¦æ ¡éªŒï¼‰
interface UploadData_check {
  uploaddata: UploadData;
  check: number;
}

// æœåŠ¡å™¨å‘å›æ•°æ®æ ¼å¼
interface ServerResponse {
  status: string;
  message: string;
  received_data: UploadData;
}

function uploadDataToString(data: UploadData): string {
  // æŒ‰å›ºå®šé¡ºåºæ‹¼æ¥æ‰€æœ‰å­—æ®µ
  return [
    data.heartRate.toString(),
    data.location.join(','),
    data.sensorData.join(','),
    data.timestamp.toString()
  ].join('|'); // ä½¿ç”¨|åˆ†éš”ä¸åŒå­—æ®µ
}

// å¼‚æˆ–æ ¡éªŒ
function xorChecksum(str: string): number {
  let checksum = 0;
  for (let i = 0; i < str.length; i++) {
    checksum ^= str.charCodeAt(i);
  }
  return checksum & 0xFF; // è¿”å›å•å­—èŠ‚æ ¡éªŒå€¼ (0-255)
}

@Entry
@Component
struct Index {
  @State heartRate: number = 0;
  @State location: Array<number> = [0,0]; //[0]ç»åº¦ [1]çº¬åº¦
  @State sensor_data: Array<number> = [0,0,0,0,0,0]; //x,y,zåŠ é€Ÿåº¦
  //ä¸Šä¼ æ•°æ®çš„å®šæ—¶å™¨å˜é‡
  @State uploadTimer: number | undefined = undefined;
  @State uploadInterval: number = 100; // 0.1ç§’ä¸Šä¼ ä¸€æ¬¡

  @State sensorInterval: number = 100000000; //åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨è¯»å–é—´éš”
  @State heartInterval: number = 100000000; //å¿ƒç‡è¯»å–é—´éš”

  //è¯·æ±‚ä½ç½®ä¿¡æ¯çš„å‚æ•°
  request: geoLocationManager.ContinuousLocationRequest= {
    //é«˜åŠŸè€—å®šä½
    locationScenario: geoLocationManager.PowerConsumptionScenario.HIGH_POWER_CONSUMPTION,
    //å®æ—¶ä¸ŠæŠ¥å®šä½
    interval:0,
  };

  //å®šæ—¶å™¨ä¸­è¯·æ±‚å•æ¬¡ä½ç½®ä¿¡æ¯å‚æ•°
  timer_request: geoLocationManager.LocationRequest = {
    priority: geoLocationManager.LocationRequestPriority.FIRST_FIX, //å¿«é€Ÿå®šä½
    maxAccuracy: 50,
    scenario: geoLocationManager.LocationRequestScenario.NAVIGATION  // ä½¿ç”¨é«˜ç²¾åº¦æ¨¡å¼
  };

  build() {
    Column() {
      Text(`æ°´ä¸Šè¿åŠ¨ç›‘æµ‹`)
        .fontSize(23)
        .fontWeight(FontWeight.Medium)
        .textAlign(TextAlign.Center)
        .margin({ bottom: 12 })
      Text(`â¤ï¸ å¿ƒç‡ï¼š${this.heartRate} bpm`)
        .fontSize(18)
        .fontWeight(FontWeight.Medium)
        .textAlign(TextAlign.Center)
        .margin({ bottom: 10 })
      Text(`ğŸ“ ç»åº¦ï¼š${this.location[0].toFixed(10)}`)
        .fontSize(18)
        .fontWeight(FontWeight.Medium)
        .textAlign(TextAlign.Center)
        .margin({ bottom: 10 })
      Text(`ğŸ“ çº¬åº¦ï¼š${this.location[1].toFixed(10)}`)
        .fontSize(18)
        .fontWeight(FontWeight.Medium)
        .textAlign(TextAlign.Center)
        .margin({ bottom: 10 })
      Text(`x:${this.sensor_data[0].toFixed(2)},y:${this.sensor_data[1].toFixed(2)},z:${this.sensor_data[2].toFixed(2)}`)
        .fontSize(18)
        .fontWeight(FontWeight.Medium)
        .textAlign(TextAlign.Center)
    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
    .alignItems(HorizontalAlign.Center)
    .backgroundColor(0x000000)
  }

  aboutToAppear() {
    this.requestHeartRatePermissionAndStart();
    this.keepScreenOn(true);
  }

  //è®¾ç½®å±å¹•å¸¸äº®
  async keepScreenOn(enable: boolean) {
    try {
      const win = await window.getLastWindow(getContext(this));
      await win.setWindowKeepScreenOn(enable);
    } catch (err) {
      console.error('è®¾ç½®å±å¹•å¸¸äº®å¤±è´¥:', JSON.stringify(err));
    }
  }

  //æƒé™è·å–
  async requestHeartRatePermissionAndStart() {
    const atManager = abilityAccessCtrl.createAtManager();
    const context = getContext(this) as common.UIAbilityContext;

    const permissions: Permissions[] = [
      'ohos.permission.READ_HEALTH_DATA' as Permissions,
      'ohos.permission.LOCATION' as Permissions,
      'ohos.permission.APPROXIMATELY_LOCATION' as Permissions,
      'ohos.permission.ACCELEROMETER' as Permissions,
      'ohos.permission.INTERNET' as Permissions
    ];

    atManager.requestPermissionsFromUser(
      context,
      permissions,
      (err: BusinessError, data: PermissionRequestResult) => {
        if (err) {
          console.error(`æƒé™è¯·æ±‚å¤±è´¥: code=${err.code}, message=${err.message}`);
          return;
        }

        // éå†æˆæƒç»“æœ
        for (let i = 0; i < data.authResults.length; i++) {
          if (data.authResults[i] !== 0) {
            console.warn(`æƒé™ ${data.permissions[i]} è¢«æ‹’ç»!`);
          }
          else {
            console.log(`æƒé™ ${data.permissions[i]} è¢«é€šè¿‡`);
          }
        }

        // åˆ¤æ–­æ˜¯å¦å…¨éƒ¨æˆæƒ
        const allGranted = data.authResults.every(result => result === 0);
        if (allGranted) {
          console.info('æ‰€æœ‰æƒé™å·²æˆæƒ,å¼€å§‹ç›‘æµ‹');
          this.startHeartRateSensor(); // å¿ƒç‡è®¢é˜…å‡½æ•°
          this.startLocationService(); // å®šä½
          this.startAccelerometer();//åŠ é€Ÿåº¦ä¼ æ„Ÿå™¨
          // this.startGpsTimer(300);//é€šè¿‡å®šæ—¶å™¨å®šä½
          // this.uploadData_test();//ä¸Šä¼ æ•°æ®ï¼ˆæµ‹è¯•ç”¨ï¼‰
          this.startUploadTimer(this.uploadInterval);//å®šæ—¶ä¸Šä¼ æ•°æ®
        } else {
          console.warn('éƒ¨åˆ†æƒé™æœªæˆæƒï¼ŒåŠŸèƒ½å¯èƒ½å—é™');
        }
      }
    );
  }



  async uploadData() {
    // æ¯ä¸€ä¸ªhttpRequestå¯¹åº”ä¸€ä¸ªHTTPè¯·æ±‚ä»»åŠ¡ï¼Œä¸å¯å¤ç”¨ã€‚
    const httpRequest = http.createHttp();
    const url = "http://124.222.53.152:8080/api/data";
    //éœ€è¦ä¸Šä¼ çš„æ•°æ®
    const sensor_data : UploadData = {
      heartRate: this.heartRate,
      location: [... this.location], // ...ä¸ºæ‰©å±•è¿ç®—ç¬¦ï¼Œç”¨äºå¯¹æ•°ç»„æˆ–å¯¹è±¡çš„æµ…æ‹·è´
      sensorData: [...this.sensor_data.slice(0,3)],
      timestamp: new Date().getTime() //è·å–å½“å‰æ—¶é—´ï¼ˆmsçº§ï¼‰
    }

    //å°†sensor_dataè½¬æˆå­—ç¬¦ä¸²åï¼Œå†è¿›è¡Œå¼‚æˆ–æ ¡éªŒ
    const dataString : string = uploadDataToString(sensor_data);
    check = xorChecksum(dataString);

    const data : UploadData_check = {
      uploaddata: sensor_data,
      check: check
    }

    const headers : HttpHeaders = {
      "Content-Type" : "application/json"
    };

    try{
      check += 1; //é€’å¢æ ¡éªŒ
      const response = await httpRequest.request(
        url,
        {
          method: http.RequestMethod.POST,
          header: headers,
          // å½“ä½¿ç”¨POSTè¯·æ±‚æ—¶æ­¤å­—æ®µç”¨äºä¼ é€’è¯·æ±‚ä½“å†…å®¹ï¼Œå…·ä½“æ ¼å¼ä¸æœåŠ¡å™¨ç«¯ä¸€è‡´ã€‚
          extraData: JSON.stringify(data),
          connectTimeout: 10000, // å¯é€‰ï¼Œé»˜è®¤ä¸º60000msã€‚
          readTimeout: 10000, // å¯é€‰ï¼Œé»˜è®¤ä¸º60000msã€‚
        }
      );

      //å¤„ç†å“åº”
      if(response.responseCode === http.ResponseCode.OK) {
        // console.info('ä¸Šä¼ æˆåŠŸ', JSON.stringify(data))
        try{
          //æ¥æ”¶æœåŠ¡å™¨å‘å›çš„æ•°æ®
          const serverResponse: ServerResponse = JSON.parse(String(response.result));
          now_time = new Date().getTime();
          console.info('ä¸Šä¼ +ä¸‹è½½å»¶æ—¶', now_time - serverResponse.received_data.timestamp); //mså»¶è¿Ÿ
          // console.info('ä¸Šä¼ æˆåŠŸï¼ŒæœåŠ¡å™¨å“åº”ï¼š', serverResponse);
        } catch (parseError) {
          console.error('æœåŠ¡å™¨å“åº”è§£æå¤±è´¥:', parseError);
        }
      } else {
        console.error(`ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š${response.responseCode}`);
      }
    } catch(error) {
      console.error('ä¸Šä¼ å¤±è´¥ï¼š', JSON.stringify(error));
    } finally {
      httpRequest.destroy();
    }
  }

  //æ·»åŠ å®šæ—¶ä¸Šä¼ 
  startUploadTimer(intervalMs : number = 5000) {
    this.stopUploadTimer();
    this.uploadTimer = setInterval(() => {
      this.uploadData();
    }, intervalMs);
    console.info(`å¯åŠ¨å®šæ—¶ä¸Šä¼ ï¼Œé—´éš”: ${intervalMs}ms`);
  }

  stopUploadTimer() {
    if (this.uploadTimer !== undefined) {
      clearInterval(this.uploadTimer);
      this.uploadTimer = undefined;
      console.info('åœæ­¢å®šæ—¶ä¸Šä¼ ');
    }
  }

  // //æµ‹è¯•ç”¨ä¸Šä¼ å‡½æ•°ï¼ŒæˆåŠŸä¸æœåŠ¡å™¨é€šä¿¡
  // async uploadData_test() {
  //   // 3. åˆ›å»º HTTP è¯·æ±‚
  //   const httpRequest = http.createHttp();
  //   // 4. å‡†å¤‡è¯·æ±‚æ•°æ®
  //   const url = "http://124.222.53.152:8080/api/data"; // ç¡®ä¿è·¯å¾„æ­£ç¡®
  //   // const url = "http://192.168.1.103:8080/api/data"; //lab_device å±€åŸŸç½‘æµ‹è¯•ç”¨
  //   const data: TestData = {
  //     key1: "value1",
  //     key2: "value2"
  //   };
  //
  //   const headers: HttpHeaders = {
  //     "Content-Type": "application/json"
  //   };
  //
  //   try {
  //     // 5. å‘é€ POST è¯·æ±‚
  //     const response = await httpRequest.request(
  //       url,
  //       {
  //         method: http.RequestMethod.POST,
  //         header: headers,
  //         extraData: JSON.stringify(data)
  //       }
  //     );
  //     // 6. å¤„ç†å“åº”
  //     if (response.responseCode === http.ResponseCode.OK) {
  //       console.info('è¯·æ±‚æˆåŠŸ:', JSON.stringify(response.result));
  //       try {
  //         let responseData:string = JSON.parse(String(response.result));
  //         console.info('æœåŠ¡å™¨è¿”å›æ•°æ®:', responseData);
  //       } catch (parseError) {
  //         console.error('JSONè§£æé”™è¯¯:', parseError);
  //       }
  //     } else {
  //       console.error(`è¯·æ±‚å¤±è´¥ï¼ŒçŠ¶æ€ç : ${response.responseCode}`);
  //       console.error('å“åº”å†…å®¹:', response.result);
  //     }
  //   } catch (error) {
  //     // 7. é”™è¯¯å¤„ç†
  //     console.error('è¯·æ±‚å‘ç”Ÿé”™è¯¯:', JSON.stringify(error));
  //     if (error) {
  //       console.error(`ä¸šåŠ¡é”™è¯¯ä»£ç : ${error.code}, ä¿¡æ¯: ${error.message}`);
  //     }
  //   } finally {
  //     // 8. é”€æ¯è¯·æ±‚å¯¹è±¡
  //     httpRequest.destroy();
  //   }
  // }

  async startAccelerometer() {
    // ä½¿ç”¨try catchå¯¹å¯èƒ½å‡ºç°çš„å¼‚å¸¸è¿›è¡Œæ•è·
    try {
      sensor.on(sensor.SensorId.ACCELEROMETER, (data: sensor.AccelerometerResponse) => {
        // console.info('Succeeded in invoking on. X-coordinate component: ' + data.x);
        // console.info('Succeeded in invoking on. Y-coordinate component: ' + data.y);
        // console.info('Succeeded in invoking on. Z-coordinate component: ' + data.z);
        this.sensor_data[0] = data.x;
        this.sensor_data[1] = data.y;
        this.sensor_data[2] = data.z;
        last_time = now_time;
        now_time = new Date().getTime();
        // console.info('è¯»å–ç”¨æ—¶ï¼š' , now_time - last_time);
      }, { interval: this.sensorInterval });//200ms
    } catch (error) {
      let e: BusinessError = error as BusinessError;
      console.error(`Failed to invoke on. Code: ${e.code}, message: ${e.message}`);
    }
  }

  async startLocationService() {
    try{
      geoLocationManager.on('locationChange',this.request, (location: geoLocationManager.Location) => {
        // console.log('å®æ—¶å®šä½ï¼šçº¬åº¦=', location.latitude, ' ç»åº¦=', location.longitude)
        this.location[0] = location.longitude;
        this.location[1] = location.latitude;
      })
    }
    catch(error){
      console.error('å®šä½å¤±è´¥ï¼š'+ error.message);}
    // throw new Error('Method not implemented.');
  }

  //é€šè¿‡å®šæ—¶å™¨è¯»å–ä½ç½®ä¿¡æ¯
  async startGpsTimer(intervalMs: number = 1000) {
    gpsTimer = setInterval(async () => {
      try {
        const location = await geoLocationManager.getCurrentLocation(this.timer_request);
        // console.info(`ç»åº¦ï¼š${location.longitude}, çº¬åº¦ï¼š${location.latitude}`);
        this.location[0] = location.longitude;
        this.location[1] = location.latitude;
      } catch (err) {
        console.error(`è·å–GPSå¤±è´¥: ${JSON.stringify(err)}`);
      }
    }, intervalMs);
  }
  async stopGpsTimer() {
    if (gpsTimer !== undefined) {
      clearInterval(gpsTimer);
      gpsTimer = undefined;
    }
  }

  startHeartRateSensor() {
    try {
      sensor.on(sensor.SensorId.HEART_RATE, (data: sensor.HeartRateResponse) => {
        this.heartRate = data.heartRate;
        // console.log(`å¿ƒç‡:${this.heartRate}`);
      }, { interval: this.heartInterval }); // æ¯1000msæ›´æ–°ä¸€æ¬¡
    } catch (err) {
      let e = err as BusinessError;
      console.error(`å¿ƒç‡è®¢é˜…å¤±è´¥ï¼Œé”™è¯¯ç : ${e.code}, ä¿¡æ¯: ${e.message}`);
    }
  }

  aboutToDisappear() {
    try {
      sensor.off(sensor.SensorId.HEART_RATE);
      sensor.off(sensor.SensorId.ACCELEROMETER_UNCALIBRATED);
      geoLocationManager.off('locationChange');
      console.log('å®šä½æœåŠ¡å…³é—­');
    } catch (err) {
      console.error("errCode:" + JSON.stringify(err));
    }
    this.keepScreenOn(false);
    this.stopGpsTimer();
  }
}